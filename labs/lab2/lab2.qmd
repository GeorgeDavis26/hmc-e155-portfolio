---
title: "Lab 2 Report"
description: "Multiplexed 7-Segment Display"
author: "George Davis"
date: "9/9/25"
categories:
  - reflection
  - labreport
draft: false
format:
  html:
    other-links:
      - text: Link to Github Repo with code
        href: https://github.com/GeorgeDavis26/e155-lab-2/tree/main/fpga/src
---

## Summary

Lab 2 focused on creating a multiplexed seven segment display by using the internal high speed oscillator to create a low frequency enable which control a mux and demux module. My design meets the proficiency requirements but I am missing the testbenches for most of my modules. 

I spent 10 hours on this lab


## Technical Documentation

The source code for this lab can be found in the associated Github repository found by following the link on the righthand side of the page.

## Block Diagram and Schematic

![Figure 1: Block Diagram of System Verilog module desgin and heirarchy](images/lab2_block-diagram.jpeg){width=3000}

Figure 1 shows the System Verilog module design for this lab including the combiantional logic, sequential logic, and the HSOSC instantation to leverage the onboard  oscilator

![Figure 2: Schematic of physical circuit layout along with blocks representing the combinational verilog code](images/lab2_schematic.jpeg){width=3000}

Figure 2 shows the physical layout of the circuit along with the pin names and numbers along with the component values and names as well. 100k ohm pull up resistors were used on the switching logic elements. 

# Seven Segment Display LED Current Calculations

![Figure 6: Current Calculations](images/calcs.jpeg){width=3000}

Figure 6 shows the calculated current for each of the GPIO pin use cases. All current draw and sink values are within the current specs for a single GPIO pin.

# AI Prototype

I gave ChatGPT the following prompt

Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.

It responded with the following statement and statement and code:

Here’s a clean, self-contained SystemVerilog design that reuses one common-anode (active-low) 7-segment decoder to service two 4-bit inputs. It time-multiplexes the single decoder, latching the result for each digit on alternating refresh ticks so you get two independent 7-bit outputs.

//------------------------------------------------------------------------------
// sevenseg_decoder_ca
//  - Common-anode 7-seg decoder (active-low outputs).
//  - Segment order: {a,b,c,d,e,f,g} = [6:0]. '0' turns a segment ON.
//------------------------------------------------------------------------------
module sevenseg_decoder_ca (
    input  logic [3:0] bin,      // 0..15
    output logic [6:0] seg_n     // active-low segments {a,b,c,d,e,f,g}
);
    always_comb begin
        unique case (bin)
            4'h0: seg_n = 7'b0000001; // 0: a b c d e f on, g off
            4'h1: seg_n = 7'b1001111; // 1
            4'h2: seg_n = 7'b0010010; // 2
            4'h3: seg_n = 7'b0000110; // 3
            4'h4: seg_n = 7'b1001100; // 4
            4'h5: seg_n = 7'b0100100; // 5
            4'h6: seg_n = 7'b0100000; // 6
            4'h7: seg_n = 7'b0001111; // 7
            4'h8: seg_n = 7'b0000000; // 8
            4'h9: seg_n = 7'b0000100; // 9
            4'hA: seg_n = 7'b0001000; // A
            4'hB: seg_n = 7'b1100000; // b
            4'hC: seg_n = 7'b0110001; // C
            4'hD: seg_n = 7'b1000010; // d
            4'hE: seg_n = 7'b0110000; // E
            4'hF: seg_n = 7'b0111000; // F
            default: seg_n = 7'b1111111; // all off
        endcase
    end
endmodule

//------------------------------------------------------------------------------
// sevenseg_mux2
//  - Time-multiplex a single decoder to drive two 7-seg outputs.
//  - Latches the decoder result for each digit on alternating ticks.
//  - Parameters let you set the refresh rate and clock frequency.
//------------------------------------------------------------------------------
module sevenseg_mux2 #(
    parameter int unsigned CLK_HZ      = 12_000_000,  // input clock (Hz)
    parameter int unsigned REFRESH_HZ  = 1000         // per-digit refresh (Hz)
) (
    input  logic        clk,
    input  logic        rst_n,

    input  logic [3:0]  nibble0,   // first value to display
    input  logic [3:0]  nibble1,   // second value to display

    // Independent 7-bit outputs for each "digit" (active-low, common anode)
    output logic [6:0]  seg0_n,    // latched output for nibble0
    output logic [6:0]  seg1_n     // latched output for nibble1
);
    // -------------------------------------------------------------------------
    // Refresh tick generator (toggle 'sel' at REFRESH_HZ per digit)
    // The decoder is evaluated every half-period so each digit updates at
    // REFRESH_HZ, and the shared decoder runs at 2*REFRESH_HZ.
    // -------------------------------------------------------------------------
    localparam int unsigned TICKS_PER_TOGGLE = (CLK_HZ / (2*REFRESH_HZ));
    localparam int CNT_W = (TICKS_PER_TOGGLE <= 1) ? 1 : $clog2(TICKS_PER_TOGGLE);

    logic [CNT_W-1:0] cnt;
    logic             sel;   // 0 -> update seg0, 1 -> update seg1
    logic             tick;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            cnt  <= '0;
            tick <= 1'b0;
        end else begin
            if (cnt == TICKS_PER_TOGGLE-1) begin
                cnt  <= '0;
                tick <= 1'b1;
            end else begin
                cnt  <= cnt + 1'b1;
                tick <= 1'b0;
            end
        end
    end

    // Toggle which digit we're servicing on each tick
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) sel <= 1'b0;
        else if (tick) sel <= ~sel;
    end

    // -------------------------------------------------------------------------
    // Single shared decoder instance
    // -------------------------------------------------------------------------
    logic [3:0]  muxed_nibble;
    logic [6:0]  dec_out_n;

    assign muxed_nibble = sel ? nibble1 : nibble0;

    sevenseg_decoder_ca u_dec (
        .bin   (muxed_nibble),
        .seg_n (dec_out_n)
    );

    // -------------------------------------------------------------------------
    // Latch the decoder's output into the appropriate digit register
    // Only the selected digit updates on each tick; the other holds steady.
    // -------------------------------------------------------------------------
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            seg0_n <= 7'b1111111; // all off
            seg1_n <= 7'b1111111; // all off
        end else if (tick) begin
            if (sel) seg1_n <= dec_out_n; // we just decoded nibble1
            else     seg0_n <= dec_out_n; // we just decoded nibble0
        end
    end
endmodule

How it works (quick notes)

sevenseg_decoder_ca is the only decoder. It produces active-low segment lines {a,b,c,d,e,f,g} for a common-anode display.

sevenseg_mux2 creates a refresh tick at 2*REFRESH_HZ (so each digit updates at REFRESH_HZ). On each tick it:

selects either nibble0 or nibble1,

runs the single decoder,

latches the result into seg0_n or seg1_n.

Outputs seg0_n and seg1_n are two independent 7-bit buses that hold steady between their refresh updates, so downstream logic (or two separate displays) can use them without needing any additional enable strobes.

If your board shares the segment lines and uses per-digit enables (common in dual-digit modules), you can instead drive one 7-bit bus plus two digit-enable lines; but since you asked for two sets of seven output bits, the above keeps them separate while still reusing a single decoder.






After this response I uploaded three of my lab 2 sv modules and gave it a similar prompt seen below:

Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.


Great — I see you’ve uploaded three .sv files. To give you exactly what you need, I’ll build a top-level module that instantiates the oscillator (from your switch_mux.sv), and the seven-segment decoder (from seven_seg_disp.sv), then multiplexes the inputs so only one decoder instance is used, but it produces two sets of outputs.

Here’s how I’d structure it:

Oscillator: drives the multiplexing clock (refresh rate).

Mux logic: alternates between in0 and in1.

Decoder: instantiated once, shared between inputs.

Registers: store the most recent decoded result for each digit.


//-----------------------------------------------------------------------------
// Top-level: two-digit time-multiplexed seven segment driver
// Reuses a single seven-segment decoder to produce two outputs
//-----------------------------------------------------------------------------

module top_two_digit (
    input  logic       clk,        // main system clock
    input  logic       rst_n,      // active-low reset
    input  logic [3:0] nibble0,    // first 4-bit input
    input  logic [3:0] nibble1,    // second 4-bit input

    output logic [6:0] seg0,       // decoded segments for nibble0
    output logic [6:0] seg1        // decoded segments for nibble1
);

    // -------------------------------------------------------------------------
    // Oscillator / refresh tick generator
    // Assuming your "switch_mux.sv" or another file gives a divided clock
    // Use that module to create `tick` for multiplexing
    // -------------------------------------------------------------------------
    logic tick;
    switch_mux u_clkdiv (
        .clk_in (clk),
        .rst_n  (rst_n),
        .tick   (tick)   // provide a ~1kHz enable pulse
    );

    // -------------------------------------------------------------------------
    // Shared seven segment decoder
    // -------------------------------------------------------------------------
    logic [3:0] nibble_mux;
    logic [6:0] seg_dec;

    seven_seg_disp u_dec (
        .bin (nibble_mux),
        .seg (seg_dec)   // active-low outputs for CA display
    );

    // -------------------------------------------------------------------------
    // Multiplex between inputs, latch into outputs
    // -------------------------------------------------------------------------
    logic sel;   // toggles between 0 and 1

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            sel <= 1'b0;
        else if (tick)
            sel <= ~sel;
    end

    assign nibble_mux = sel ? nibble1 : nibble0;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            seg0 <= 7'h7F; // all off
            seg1 <= 7'h7F;
        end else if (tick) begin
            if (sel)
                seg1 <= seg_dec; // update digit1
            else
                seg0 <= seg_dec; // update digit0
        end
    end

endmodule


✅ This top module does what you asked:

Only one decoder (seven_seg_disp) is used.

The oscillator (switch_mux) generates a refresh tick.

On each tick, we feed the decoder either nibble0 or nibble1.

The decoded value is latched into seg0 or seg1.

Would you like me to integrate directly with the exact ports and naming from your uploaded seven_seg_disp.sv and switch_mux.sv (so it compiles with no edits), or do you just want this template structure?

## Reflect


The AI prototype was synthesized in the Lattice Radiant Software with minimal warnings. In general, I was impressed with ChatGPT's code. I can't be certain that the code works until I run a sim or verify the functionality on a working physical FPGA, but by inspection, it seems to function. However, with my relatively experienced knowledge base of System Verilog and FPGAs, the code used syntax and keywords that I was not used to. I think if I were to use this code to perform the function of my lab, I would not be able to debug as rapidly as I did with my own code. A HUGE benefit of writing your own code in digital design is being able to discern between a software and a hardware issue. If I didn't write the code myself, I would likely waste a lot more time debugging. This is only true in my era of limited experience. I can imagine a hardware engineering pro with years of experience could understand and absorb the code the LLM gave very quickly to the point where they would understand it like their own. To some extent, it's like a junior developer wrote code for you. Those skills exist in the world, but they are hard fought, and I am not there yet!


A piece of syntax that ChatGPT used that I am unfamiliar with came in its instantiation of TICKS_PER_TOGGLE, where it defined a "localparam int unsigned". I could make a guess at what this is, but really have no idea what it means to the level that is necessary to be able to interact with it once an issue inevitably comes up. What I have gathered from this class thus far is that NOTHING works on the first try, and problem-solving is almost necessary. If I can't understand the code, it is useless.




After I uploaded my own sv files, the code the LLM produced was much more understandable. If I enter the industry or ever have an ambitious personal project, I think this is the best method to make sure the LLM gives me something I can understand and not reference some decade-old old stackoverflow code from a senior engineer.