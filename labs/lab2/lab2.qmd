---
title: "Lab 2 Report"
description: "Multiplexed 7-Segment Display"
author: "George Davis"
date: "9/9/25"
categories:
  - reflection
  - labreport
draft: false
format:
  html:
    other-links:
      - text: Link to Github Repo with code
        href: https://github.com/GeorgeDavis26/e155-lab-2/tree/main/fpga/src
---

## Summary

Lab 2 focused on creating a multiplexed seven segment display by using the internal high speed oscillator to create a low frequency enable which control a mux and demux module. My design meets the proficiency requirements but I am missing the testbenches for most of my modules. 

I spent 10 hours on this lab

## Functional Demonstation

(images/dual_seven_seg.jpeg){width=3000}


## Technical Documentation

The source code for this lab can be found in the associated Github repository found by following the link on the righthand side of the page.

## Block Diagram and Schematic

![Figure 1: Block Diagram of System Verilog module desgin and heirarchy](images/lab2_block-diagram.jpeg){width=3000}

Figure 1 shows the System Verilog module design for this lab including the combiantional logic, sequential logic, and the HSOSC instantation to leverage the onboard  oscilator

![Figure 2: Schematic of physical circuit layout along with blocks representing the combinational verilog code](images/lab2_schematic.jpeg){width=3000}

Figure 2 shows the physical layout of the circuit along with the pin names and numbers along with the component values and names as well. 100k ohm pull up resistors were used on the switching logic elements. 

# Seven Segment Display LED Current Calculations

![Figure 6: Current Calculations](images/calcs.jpeg){width=3000}

Figure 6 shows the calculated current for each of the GPIO pin use cases. All current draw and sink values are within the current specs for a single GPIO pin.

# AI Prototype

I gave ChatGPT the following prompt

Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.

After this response I uploaded three of my lab 2 sv modules and gave it a similar prompt seen below:

Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.

## Reflection


The AI prototype was synthesized in the Lattice Radiant Software with minimal warnings. In general, I was impressed with ChatGPT's code. I can't be certain that the code works until I run a sim or verify the functionality on a working physical FPGA, but by inspection, it seems to function. However, with my relatively experienced knowledge base of System Verilog and FPGAs, the code used syntax and keywords that I was not used to. I think if I were to use this code to perform the function of my lab, I would not be able to debug as rapidly as I did with my own code. A HUGE benefit of writing your own code in digital design is being able to discern between a software and a hardware issue. If I didn't write the code myself, I would likely waste a lot more time debugging. This is only true in my era of limited experience. I can imagine a hardware engineering pro with years of experience could understand and absorb the code the LLM gave very quickly to the point where they would understand it like their own. To some extent, it's like a junior developer wrote code for you. Those skills exist in the world, but they are hard fought, and I am not there yet!


A piece of syntax that ChatGPT used that I am unfamiliar with came in its instantiation of TICKS_PER_TOGGLE, where it defined a "localparam int unsigned". I could make a guess at what this is, but really have no idea what it means to the level that is necessary to be able to interact with it once an issue inevitably comes up. What I have gathered from this class thus far is that NOTHING works on the first try, and problem-solving is almost necessary. If I can't understand the code, it is useless.




After I uploaded my own sv files, the code the LLM produced was much more understandable. If I enter the industry or ever have an ambitious personal project, I think this is the best method to make sure the LLM gives me something I can understand and not reference some decade-old old stackoverflow code from a senior engineer.