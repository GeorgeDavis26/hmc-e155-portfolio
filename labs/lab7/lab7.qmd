---
title: "Lab 7 Report"
description: "Advanced Encryption Standard (AES)"
author: "George Davis"
date: "11/6/25"
categories:
  - reflection
  - labreport
draft: false
format:
  html:
    other-links:
      - text: Link to Github Repo with code
        href: https://github.com/GeorgeDavis26/e155_lab7_gd
---

## Summary

This lab focused on implementing the AES 128 bit encryption referenced from the NIST FIPS 197 document that can be 
found on the E155 course page under my resources tab. I only went for proficiency on this lab meaning I only had to pass the provided aes_core and aes_spi testbenches. I did so and therefore should get proficiency in this lab. There
is code to send the plaintext from the mcu via SPI to be encypted on the FGPA to be sent back if one were to wish to
take this function further.

I spent about 28 hours on this lab (a lot on the block diagram!)

## Testbench Passing


## Technical Documentation

The source code for this lab can be found in the associated Github repository found by following the link on the righthand side of the page.

## Schematic

![aes_spi_testbench: Waveforms](images/aes_spi_waves.jpg){width=3000}

![aes_spi_testbench: Successful Testbench Message](images/aes_spi_success.jpg){width=3000}

![aes_core_testbench: Waveforms](images/aes_waves.jpg){width=3000}

![aes_core_testbench: Successful Testbench Message](images/aes_success.jpg){width=3000}

# Block Diagram

![Block Diagram: lab7_gd_aes](images/lab7_bd-gd_lab7_block.jpg){width=3000}

![Block Diagram: aes_core](images/lab7_bd-aes_core_block.jpg){width=3000}

![Block Diagram: mix_columns](images/lab7_bd-mic_cols_block.jpg){width=3000}

![Block Diagram: aes_spi](images/lab7_bd-aes_spi_block.jpg){width=3000}

# Schematic

![Lab 7 Schematic and Onboard wiring](images/lab7_bd-schematic.jpg){width=3000}

# AI Prototype
I prompted Chat GPT with…

Write SystemVerilog HDL to implement the KeyExpansion logic described in the FIPS-197 uploaded document. The module should be purely combinational, using the previous key and current round number to calculate the next key. Assume other required modules (SubWord and RotWord) are already implemented.

This code had solid syntax and flow, but I don’t think it properly implemented the KeyExpansion logic from the provided FIPS document. It doesn’t compute 4 ∗ (Nr + 1) words as FIPS specifies, and only the first four. Upon prompting it about this, I got it to reveal its potential mistake, and it offered to fix the code. However, I think when prompted with such a large document, it might struggle to track down the correct information. However, this code isn’t useless. One would have to just call the module at the beginning of each round to get the proper number of keys. This might be the best and most efficient way to compute the w words from the key, but it is not how I would have done it.

I then prompted ChatGPT with..

Write SystemVerilog HDL to implement the following logic:

i = 0

while i < Nk do

    w[i] <- key[4*i..4*i+3]

    i <- i+1

end while

while i <= 4 * Nr + 3 do

    temp <- w[i-1]

    if i mod Nk = 0 then

        temp <- module1(module2(temp)) (+) Rcon[i/Nk]

    else if Nk > 6 and i mod Nk = 4 then

        temp <- module1(temp)

    end if

    w[i] <- w[i-Nk] (+) temp

    i <- i + 1

end while

return w

Assume module1 and module2 are existing modules that can be instantiated. (+) refers to XOR. Unwrap the loop in the provided pseudo code so it uses the previous iterations output to generate the new iteration.

Do not use any existing knowledge of the AES specifications in your answer.

It gave me a code snippet that seemed less functional than the previous one. For example, it had no case to not compute the first four words every time, even though it would be unnecessary. But to be honest, this code block used Verilog I don’t understand, like the “generate” statement. Maybe if I were more experienced, I could interpret this module better, but at the moment, this is a worse response for the LLM.

Unsurprisingly, the response with the linked FIPS document was more usable and easier to understand. However, I think there would be a good amount of startup to get it working in my lab. I think there is a lot to be gained from the LLM's approach to the module. I think I could maybe modify the code it gave me to better suit what I am comfortable with in Verilog and perform optimally as it displayed.
